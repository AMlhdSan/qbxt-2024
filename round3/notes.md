
# $Round$ $3$ $Notes$

## $T1$ $不$

> ### 题目描述
> 
> 定义一个物品可以用一个二元组 $(a,b)$ 来描述，定义两个物品 $x$ 和 $y$ 匹配的贡献为 $\max\{ a_x + a_y , b_x + b_y \}$ 。
> 
> 有两个物品集合 $L$ 和 $C$ ，初始为空，有 $n$ 次操作，每次操作为从其中一个物品集合中加入或删除一个物品，每次操作之后在两个物品集合中分别选择一个物品，计算其可能的最小的匹配贡献，如果存在物品集合为空则无解。
> 
> ~~时间限制 $2$ 秒~~，空间限制 $1024 MB$。
> 
> 由于评测机运行效率差异，本题时间限制修改为 $2.5$ 秒。
> 
> ### 输入格式
> 
> 第一行一个正整数 $T$ 表示操作次数。
> 
> 接下来 $T$ 行，每行四个整数 $opt,d,a,b$ ，其中当前物品为 $(a,b)$ ， $opt=1/0$ 表示加入 / 删除， $d=0/1$ 表示加入集合 $L$ / $C$ 。
> 
> 保证删除物品时该物品存在。
> 
> ### 输出格式
> 
> 对于每次操作，输出操作之后所有可能的最小的匹配贡献，如果存在物品集合为空则输出 `-1` 。
> 
> ### 样例 #1
> 
> #### 样例输入 #1
> 
> ```
> 6
> 1 0 5 10
> 1 1 100 23
> 1 1 1 45
> 1 1 22 33
> 1 0 2 3
> 0 1 22 33
> ```
> 
> #### 样例输出 #1
> 
> ```
> -1
> 105
> 55
> 43
> 36
> 48
> ```
> 
> ### 提示
> 
> 对于 $20\%$ 的数据，保证 $1 \leq T \leq 100$ 。
> 
> 对于 $50\%$ 的数据，保证 $1 \leq T \leq 1000$ 。
> 
> 对于 $80\%$ 的数据，保证 $1 \leq T \leq 2 \times 10^5$ 。
> 
> 对于 $100\%$ 的数据，保证 $1 \leq T \leq 10^6 , 1 \leq a_i , b_i \leq 10^9$ 。

1. $min$ 和 $max$ 存在冲突！

2. 拆开来看：如果假设 $a_i+a_j>b_i+b_j$

3. 但是不符合！

4. 没有条件就创造条件！移项！

5. $a_i-b_i \ge b_j-a_j$ $\Rightarrow$ $c_i=a_i-a_j,c_j=b_j-b_i$

6. 值域线段树（左边一定在右边的左边）

## $T2$ $远$

> ### 题目描述
> 
> 给定一个长度为 $n$ 的一次函数序列 $f_i(x) = a_i x + b_i$ ，定义一个函数序列的代价为，将该序列内的所有一次函数任意重排，初始定义 $x=0$ ，将 $x$ 代入到一次函数中并得到其函数值，将函数值设置为 $x$ ，即 $x \leftarrow f_i(x)$ ，按顺序依次处理完所有函数后得到最终的 $x$ ，则代价为所有重排方案中最终的 $x$ 的最小值。
> 
> 现在需要将这个长度为 $n$ 的一次函数序列划分成若干个连续子段，使得满足所有连续子段的代价之和 $\leq c$ ，保证 $c \geq \sum\limits_{i=1}^{n} b_i$ ，询问所有合法划分方案中的最小的划分段数，以及在保持最小划分段数的所有方案中的最小代价。
> 
> 时间限制 2 秒，空间限制 512 MB。
> 
> ### 输入格式
> 
> 第一行两个整数 $n,c$ 。
> 
> 接下来 $n$ 行第 $i$ 行输入两个非负整数 $a_i,b_i$ 。
> 
> ### 输出格式
> 
> 第一行两个整数，分别表示最小划分段数和在此基础上的最小代价。
> 
> ### 样例 #1
> 
> #### 样例输入 #1
> 
> ```
> 5 965
> 1 7
> 2 10
> 1 7
> 2 1
> 2 9
> ```
> 
> #### 样例输出 #1
> 
> ```
> 1 46
> ```
> 
> ### 样例 #2
> 
> #### 样例输入 #2
> 
> ```
> 5 64
> 1 8
> 3 7
> 3 4
> 4 9
> 1 8
> ```
> 
> #### 样例输出 #2
> 
> ```
> 2 44
> ```
> 
> ### 提示
> 
> 对于 $100\%$ 的数据，保证 $1 \leq n \leq 2000$，$1 \leq a_i \leq 10^5$，$0 \leq \sum\limits_{i=1}^{n} b_i \leq c \leq 10^8$。
> 
> | 测试点编号        | $n \leq$ | 特殊性质 |
> |:------------:|:--------:|:----:|
> | $1 \sim 4$   | $10$     | 无    |
> | $5 \sim 8$   | $100$    | 无    |
> | $9 \sim 12$  | $500$    | 无    |
> | $13 \sim 16$ | 无        | A    |
> | $17 \sim 20$ | 无        | 无    |
> 
> 特殊性质 A：保证 $1 \leq a_i \leq 2$。

1. 当 $a_i\ge 2$ 的时候，指数增长会很大，所以一段不会很多。

2. 当 $a_i=1$ 时，要放到最后 $\Rightarrow$ 把 $a_i=1$ 给去掉 $\Rightarrow$ $a_i\ge 2$。

## $T3$ $万$

> ### 题目描述
> 
> 给定一个长度为 $n$ 的排列 $p$ ，我们知道通过若干次对相邻两项进行交换，可以将排列 $p$ 进行从小往大的排序。
> 
> 接下来，询问对于给定的排列 $p$ ，有多少种操作顺序可以使得每个相邻两个位置之间恰好交换一次。更准确的说，询问有多少个长度为 $n-1$ 的排列 $a$ 满足，从前往后依次交换 $p_{a_i}$ 和 $p_{a_i+1}$ ，使得可以将原排列 $p$ 升序排序。
> 
> 进一步的，给定一个长度为 $n$ 的序列 $q$ ，保证 $q$ 中非零元素两两不同，询问所有满足长度为 $n$ 的、且满足若 $q_i \not = 0$ 则有 $p_i = q_i$ 的排列 $p$ 的合法操作顺序数量之和。
> 
> 时间限制 1 秒，空间限制 1024MB。
> 
> ### 输入格式
> 
> 输入的第一行包含一个正整数 $n$ 。
> 
> 输入的第二行包含 $n$ 个非负整数，第 $i$ 个元素为 $q_i$ 。
> 
> ### 输出格式
> 
> 输出一行包含一个整数，表示所有排列的合法操作数量之和 $\bmod \ 998244353$ 的结果。
> 
> ### 样例 #1
> 
> #### 样例输入 #1
> 
> ```
> 5
> 0 0 2 0 0
> ```
> 
> #### 样例输出 #1
> 
> ```
> 4
> ```
> 
> ### 样例 #2
> 
> #### 样例输入 #2
> 
> ```
> 5
> 4 0 0 0 3
> ```
> 
> #### 样例输出 #2
> 
> ```
> 3
> ```
> 
> ### 提示
> 
> 对于全部数据，保证 $2 \leq n \leq 5000$ ， $0 \leq q_i \leq n$  。
> 
> | 测试点编号        | $n \leq$ | 特殊性质 |
> | ------------ | -------- | ---- |
> | $1 \sim 4$   | $10$     |      |
> | $5 \sim 6$   | $20$     |      |
> | $7 \sim 8$   | $50$     |      |
> | $9 \sim 12$  | $300$    |      |
> | $13 \sim 14$ | 无        | A    |
> | $15 \sim 16$ | 无        | B    |
> | $17 \sim 20$ | $5000$   |      |
> 
> 特殊性质 A：保证对于所有的 $i$ 均有 $q_i \not = 0$  ；
> 
> 特殊性质 B：保证对于所有的 $i$ 均有 $q_i = 0$  。

1. 若将 $p_i$ 移动到自己的位置上，这经过的点都必须小于 $p_i$ 。

2. 那换有什么顺序要求吗？

3. 如果 $p$ 确定

4. $dp[t][i]$ 表示前 $t$ 次操作最后一个是第 $i$ 个执行的 $\Rightarrow$ 加入一个：相对顺序关系：
   
   *  $j<i$ ： $dp[t][i] \rightarrow dp[t+1][j]$
   
   *  $j>i$ ： $dp[t][i] \rightarrow dp[t+1][j]$

5. 如果不确定呢？

6. 拓扑排序



## $T4$ $里$

> ### 题目描述
> 
> 给定一个 $n$ 个点 $n$ 条边构成的图，其中边 $i$ 连接点 $i$ 和点 $a_i$ 。我们称点 $i$ 周围的点为与点 $i$ 在图上最短距离 $\leq 1$ 的点，注意点 $i$ 自身是点 $i$ 周围的点。点 $i$ 有 $b_i$ 的权值。
> 
> 定义点 $i$ 的权值 $c_i$ 为，依次处理每一个点 $x$ ，设 $d$ 表示点 $x$ 周围的点的数量，此时点 $x$ 将其所有周围的点 $y (y \not = x)$ 的权值 $c_y$ 增加 $\lfloor \frac{b_x}{d} \rfloor$ ，并将点 $x$ 的权值 $c_x$ 增加 $b_x - (d-1) \lfloor \frac{b_x}{d} \rfloor$ ，对所有点 $x$ 处理完后得到所有点的权值 $c$ 序列。
> 
> 有 $m$ 次操作，每次操作有三种类型：
> 
> 1. 给定 $x$ 和 $y$ ，此时将原先的边 $x$ 删除，并将 $a_x$ 修改为 $y$ ，再将当前的边 $x$ 加入。
> 2. 给定 $x$ ，询问当前图中点 $x$ 的权值 $c_x$ 。
> 3. 查询当前图中所有点权值 $c$ 的最小值和最大值。
> 
> 时间限制 2 秒，空间限制 512 MB。
> 
> ### 输入格式
> 
> 第一行两个整数 $n,m$ 。
> 
> 第二行 $n$ 个整数，第 $i$ 个整数表示 $a_i$ 。
> 
> 第三行 $n$ 个整数，第 $i$ 个整数表示 $b_i$ 。
> 
> 接下来 $m$ 行每行一到三个整数，第一个整数为 $op$ ，表示操作类型，接下来输入的整数表示操作参数。
> 
> ### 输出格式
> 
> 对于每次类型二和类型三的操作，输出一行表示答案。
> 
> ### 样例 ###1
> 
> #### 样例输入 ###1
> 
> ```
> 5 10
> 3 5 5 3 4 
> 8 2 2 3 5 
> 3
> 1 1 4
> 2 1
> 1 1 3
> 2 1
> 1 2 3
> 2 2
> 1 1 3
> 2 1
> 3
> ```
> 
> #### 样例输出 ###1
> 
> ```
> 2 8
> 4
> 4
> 1
> 4
> 1 9
> ```
> 
> ### 样例 ###2
> 
> #### 样例输入 ###2
> 
> ```
> 10 20
> 5 7 7 5 7 5 4 4 7 5 
> 61 905 409 562 878 600 57 500 732 66 
> 3
> 1 1 5
> 2 1
> 1 2 5
> 2 2
> 1 3 7
> 2 3
> 1 3 4
> 2 3
> 1 4 5
> 2 4
> 1 4 5
> 2 4
> 1 2 4
> 2 2
> 1 1 7
> 2 1
> 1 1 7
> 2 1
> 3
> ```
> 
> #### 样例输出 ###2
> 
> ```
> 177 1320
> 177
> 578
> 216
> 317
> 707
> 707
> 546
> 42
> 42
> 42 1189
> ```
> 
> ### 提示
> 
> 本题开启子任务评测。
> 
> 子任务 1（10 分）：保证 $n \leq 1000$ 。
> 
> 子任务 2（20 分）：保证没有操作一。
> 
> 子任务 3（20 分）：保证没有操作二。
> 
> 子任务 4（20 分）：保证没有操作三。
> 
> 子任务 5（30 分）：无特殊限制。
> 
> 对于所有数据，保证 $3 \leq n \leq 10^5 , 1 \leq m \leq 2 \times 10^5$ ，保证任意时刻给定的图不存在自环和二元环。
