# $Round$ $4$ $Notes$

## $T1$ $绝$

> ## 题目描述
> 
> 费马大定理：对于任意的 $\geq 2$ 的正整数 $n$ ，有 $a^{n} + b^{n} = c^{n}$ 不存在整数解。
> 
> 当 $n=3$ 时，费马大定理的方程形如 $a^{3} + b^{3} = c^{3}$ ，现在我们将方程稍作修改，即 $a^{3} + b^{3} = (c3) = 10c+3$ 。接下来给定 $l,r$ ，询问有多少个正整数 $a,b,c$ 满足 $l \leq a,b,c \leq r$ 且 $a^{3} + b^{3} = 10c+3$ 。
> 
> 时间限制 1 秒，空间限制 512 MB。
> 
> ## 输入格式
> 
> 输入的第一行包含一个正整数 $t$ ，表示测试数据组数。对于每组测试数据：
> 
> 输入的第一行包含两个正整数 $l,r$ ，表示 $a,b,c$ 的限制范围。
> 
> ## 输出格式
> 
> 对于每组测试数据：输出一行表示满足条件的正整数对 $(a,b,c)$ 的数量。
> 
> ## 样例 #1
> 
> ### 样例输入 #1
> 
> ```
> 3
> 1 49
> 4 100
> 9 200
> ```
> 
> ### 样例输出 #1
> 
> ```
> 4
> 2
> 0
> ```
> 
> ## 提示
> 
> 对于 $100\%$ 的数据，保证 $1 \leq t \leq 2 \times 10^{3}$ ，$1 \leq l \leq r \leq 10^{9}$ 。
> 
> | 测试点编号 | $1 \leq l \leq r \leq$ |
> | --- | --- |
> | $1 \sim 4$ | $50$ |
> | $5 \sim 8$ | $200$ |
> | $9 \sim 12$ | $10^{7}$ |
> | $13 \sim 16$ | $10^8$ |
> | $17 \sim 20$ | $10^{9}$ |

直接模拟就可以了，加一点尾数优化。

## $T2$ $世$

> ## 题目描述
> 
> 有一个 $1 \times n$ 的地图，对于地图上的这 $n$ 个格子，每个格子都是来自一个阵营的国家，第 $i$ 个国家来自于阵营 $a_i$ 。第 $i$ 个国家和左侧的第 $i-1$ 个国家相邻，以及和右侧的第 $i+1$ 个国家相邻，第 $1$ 个国家左侧没有相邻国家，第 $n$ 个国家右侧没有相邻国家。
> 
> 有一名旅行者当前停留在一个国家，这名旅行者具有强大的影响力，具体来说，定义一次操作为以下两种类型之一：
> 
> 1. 旅行者指定一个国家进行策反，使得这个国家的阵营被划分为指定阵营，即可以对于序列 $a$ 进行单点修改。该操作花费 $1$ 的代价。
> 2. 旅行者可以移动到相邻的阵营相同的国家。该操作花费 $1$ 的代价。
> 
> 有 $m$ 组询问，每组询问形如，对于初始的世界阵营格局，旅行者从国家 $x$ 移动到国家 $y$ 的最小代价。
> 
> 时间限制 1.5 秒，空间限制 512 MB。
> 
> ## 输入格式
> 
> 输入的第一行包含两个正整数 $n,m$ 。
> 
> 输入的第二行包含 $n$ 个正整数 $a_1 , \dots , a_n$ 。
> 
> 接下来 $m$ 行每行两个正整数 $x,y$ ，表示一组询问。
> 
> ## 输出格式
> 
> 输出 $m$ 行，第 $i$ 行表示对于第 $i$ 个询问的答案，容易发现一定有解。
> 
> ## 样例 #1
> 
> ### 样例输入 #1
> 
> ```
> 8 5
> 1 2 5 4 1 2 1 4 
> 8 6
> 7 6
> 7 2
> 2 6
> 3 2
> ```
> 
> ### 样例输出 #1
> 
> ```
> 4
> 2
> 9
> 7
> 2
> ```
> 
> ## 样例 #2
> 
> ### 样例输入 #2
> 
> ```
> 10 8
> 3 1 3 3 3 1 3 1 2 1 
> 3 4
> 6 8
> 2 3
> 8 2
> 5 3
> 4 2
> 8 7
> 5 1
> ```
> 
> ### 样例输出 #2
> 
> ```
> 1
> 3
> 2
> 9
> 2
> 3
> 2
> 5
> ```
> 
> ## 提示
> 
> 对于 $100\%$ 的数据，保证 $1 \leq n,m \leq 10^{6}$ ，$1 \leq a_i ,x,y \leq n$ 。
> 
> | 测试点编号 | $n \leq $ | 特殊性质 |
> | --- | --- | --- |
> | $1 \sim 4$ | $10^{4}$ | A   |
> | $5 \sim 8$ | $10^{5}$ | B   |
> | $9 \sim 14$ | $5000$ | C   |
> | $15 \sim 20$ | $10^{6}$ | 无   |
> 
> 特殊性质 A：保证 $a_i , m \leq 100$。
> 
> 特殊性质 B：保证 $m \leq 10^{5}$ 且 $a_i \leq 3$。
> 
> 特殊性质 C：保证 $m \leq 5000$。同上

1. 划分成连通快
  
2. 不断“跳跃”，形成一棵树
  
3. 类似于找最近公共祖先。
  

## $T3$ $高$

> ## 题目描述
> 
> 给定一棵 $n$ 个节点的树，第 $i$ 个节点的颜色为 $a_i$ 。
> 
> 接下来我们可以割掉这棵树上的若干条边，使得这棵树被分割成若干个连通块，我们定义一种割边方案的权值为，对于一个连通块，若存在一种颜色的所有点均在该连通块内，则该连通块权值为 $1$ ，否则为 $0$ ，一种割边方案的权值即为其分割出来的所有连通块的权值和。
> 
> 询问最大的可行的割边方案的权值。
> 
> 时间限制 6 秒，空间限制 1024 MB。
> 
> ## 输入格式
> 
> 输入的第一行包含一个正整数 $t$ ，表示测试数据组数。
> 
> 对于每组测试数据：
> 
> 输入的第一行包含一个正整数 $n$ ，表示树的大小。
> 
> 输入的第二行包含 $n$ 个正整数 $a_1 , \dots , a_n$ 。
> 
> 接下来输入 $n-1$ 行，每行两个正整数 $u,v$ 描述树上一条边 $(u,v)$ 。
> 
> ## 输出格式
> 
> 对于每组测试数据，输出一行一个整数表示最大的可行的割边方案的权值。
> 
> ## 样例 #1
> 
> ### 样例输入 #1
> 
> ```
> 3
> 6
> 3 1 2 2 1 2 
> 1 2
> 1 3
> 3 4
> 3 5
> 3 6
> 4
> 3 3 2 2 
> 1 2
> 2 3
> 2 4
> 6
> 1 3 1 2 1 3 
> 1 2
> 2 3
> 1 4
> 1 5
> 3 6
> ```
> 
> ### 样例输出 #1
> 
> ```
> 2
> 1
> 2
> ```
> 
> ## 样例 #2
> 
> ### 样例输入 #2
> 
> ```
> 3
> 7
> 4 5 1 1 3 3 1 
> 1 2
> 1 3
> 2 4
> 2 5
> 1 6
> 4 7
> 8
> 2 4 2 1 1 1 3 4 
> 1 2
> 1 3
> 3 4
> 2 5
> 2 6
> 1 7
> 2 8
> 8
> 4 3 2 4 3 1 1 4 
> 1 2
> 2 3
> 3 4
> 2 5
> 3 6
> 1 7
> 2 8
> ```
> 
> ### 样例输出 #2
> 
> ```
> 2
> 3
> 2
> ```
> 
> ## 提示
> 
> 对于所有数据，保证 $1 \leq t \leq 3$ ，$1 \leq n \leq 10^{6}$ ，$1 \leq a_i \leq n$ 。
> 
> | 测试点编号 | $n \leq$ | 特殊性质 |
> | --- | --- | --- |
> | $1 \sim 2$ | $20$ | 无   |
> | $3 \sim 6$ | $3000$ | 无   |
> | $7 \sim 12$ | $10^{5}$ | 无   |
> | $13 \sim 14$ | $10^{6}$ | A   |
> | $15 \sim 16$ | $10^{6}$ | B   |
> | $17 \sim 20$ | $10^{6}$ | 无   |
> 
> 特殊性质 A：保证 $1 \leq a_i \leq 3$ 。
> 
> 特殊性质 B：保证所有边均形如 $(i-1,i)$ 的形式。同上

1. 很巧妙的贪心模型
  
2. 直接 $dfs$ ，如果一个点的子树内有一种颜色所有都在子树内，直接将它和父亲节点断掉，不断断掉，直到最后。
  
3. 为什么正确？？
  
4. 想一想，如果碰到了一个点，满足上述的性质，如果不断，再继续往上递归，那么对于这一种颜色，最大的贡献也就是 $1$ 。但是如果我断了，那么它的父亲节点还**有可能**会完全包含其他颜色，就有可能会产生更多的贡献。
  
5. 最近公共祖先！所有颜色可能贡献的点只可能是它们的共同的祖先的父节点。
  
6. 如何求一堆点的最近公共祖先？取出dfs序中序最早和最晚的两个点求 $LCA$ 即可。
  

## $T4$ $手$

> ## 题目描述
> 
> 给定两个长度为 $n$ 的序列 $s$ 和 $t$ ，保证序列 $s$ 和 $t$ 均只包含字符 `1` 和 `2` 。给定代价系数 $C$ 。
> 
> 接下来，你可以对 $s$ 进行如下操作：
> 
> - 选择一个位置 $i$ 满足 $1 \leq i \leq n-1$ ，以 $C+s_{i}+s_{i+1}$ 的代价交换 $s_{i}$ 与 $s_{i+1}$ 。
> - 选择一个位置 $i$ 满足 $1 \leq i \leq n-2$ ，以 $C+s_{i}+s_{i+1}+s_{i+2}$ 的代价交换 $s_{i}$ 与 $s_{i+2}$ 。
> 
> 计算经过若干操作后将 $s$ 变成 $t$ 的最小代价。
> 
> 时间限制 2 秒，空间限制 512 MB。
> 
> ## 输入格式
> 
> 输入的第一行包含两个整数 $n$ 和 $C$ 。
> 
> 输入的第二行包含一个长度为 $n$ 的由字符 `1` 和 `2` 构成的字符串 $s$ 。
> 
> 输入的第三行包含一个长度为 $n$ 的由字符 `1` 和 `2` 构成的字符串 $t$ 。
> 
> ## 输出格式
> 
> 输出的第一行包含一个整数，表示经过若干次操作将 $s$ 变成 $t$ 的最小代价。
> 
> ## 样例 #1
> 
> ### 样例输入 #1
> 
> ```
> 6 5
> 212111
> 112121
> ```
> 
> ### 样例输出 #1
> 
> ```
> 18
> ```
> 
> ## 样例 #2
> 
> ### 样例输入 #2
> 
> ```
> 10 662
> 2122211111
> 2111112122
> ```
> 
> ### 样例输出 #2
> 
> ```
> 4663
> ```
> 
> ## 提示
> 
> 对于 $100\%$ 的数据，保证 $1 \leq n \leq 5000$ 且 $0 \leq C \leq 1000$ ，保证序列 $s$ 和 $t$ 中字符 `1` 和字符 `2` 的数量相同。
> 
> | 子任务编号 | $n \leq$ | 特殊性质 | 子任务分值 |
> | --- | --- | --- | --- |
> | 1   | $10$ | 无   | $20$ |
> | 2   | $100$ | 无   | $20$ |
> | 3   | $500$ | 无   | $20$ |
> | 4   | $5000$ | A   | $20$ |
> | 5   | $5000$ | 无   | $20$ |
> 
> 特殊性质 A : 保证序列 $t$ 中所有字符 `1` 均在字符 `2` 之前。为什么？
