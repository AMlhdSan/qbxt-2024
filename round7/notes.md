# $Round$ $7$ $Notes$

## $T1$ $滚球$

> ## 题目描述
> 
> 在一条直线道路上有 $n$ 个球在做匀速直线运动，第 $i$ 个球初始在位置 $x_i$，速度是 $v_i$，$v_i$ 的正负表示这个球的方向是往左还是往右，如果在某一时刻两个球到达了同一位置，则他们会发生碰撞。
> 
> 现在请你在这条道路上拿走最多 $k$ 个球，使得剩下的球中，最早发生的碰撞时间最晚。
> 
> ## 输入格式
> 
> 第一行两个数 $n,k$。
> 
> 接下来 $n$ 行，每行两个数 $x_i,v_i$。
> 
> ## 输出格式
> 
> 如果可以让剩下的球永远不碰撞，输出字符串 `Forever`。
> 
> 否则输出最早碰撞时间的最大值，绝对误差在 $10^{-3}$ 以内视为正确。
> 
> ## 样例 #1
> 
> ### 样例输入 #1
> 
> ```
> 4 1
> 1 1
> 3 -1
> 5 2
> 7 -2
> ```
> 
> ### 样例输出 #1
> 
> ```
> 1.0000
> ```
> 
> ## 样例 #2
> 
> ### 样例输入 #2
> 
> ```
> 4 2
> 1 1
> 3 -1
> 5 2
> 7 -2
> ```
> 
> ### 样例输出 #2
> 
> ```
> Forever
> ```
> 
> ## 提示
> 
> 本题采用捆绑测试。
> 
> 所有数据满足 $1 \le k \le n \le 10^5,|x_i|,|v_i| \le 10^9$。初始 $x$ 互不相同。
> 
> ### 子任务 1（9 pts）
> 
> $n \le 20$。
> 
> ### 子任务 2（16 pts）
> 
> $n \le 200, k \le 10$。
> 
> ### 子任务 3（14 pts）
> 
> $n \le 200$。
> 
> ### 子任务 $4$（12 pts）
> 
> $n \le 2000,k \le 10$。
> 
> ### 子任务 $5$（19 pts）
> 
> $n \le 2000$。
> 
> ### 子任务 $6$（30 pts）
> 
> $n \le 10^5$。

见本人的[题解](https://www.luogu.com.cn/article/b71jh4mi)

## 题意简述

线段上有$n$个点在做匀速直线运动，每个点有一个初始位置$x_i$和速度$v_i$，现在~~杀掉~~挑出$k$只蚂蚁走，求剩下的蚂蚁相撞的最小时间。如果永远无法相撞，输出`Infinity`。

## 题解

首先考虑基本解法。

对于求这种最大时间等的问题（特别是带精度的），大概率都是**二分答案**来做。本题考虑**二分答案**。

枚举$l=0.0$，$r=2e9$和$mid=\cfrac{(l+r)}{2}$，并写一个`check`函数，判断当最短时间为$mid$时是否可以做到。

注意到，只有相邻两个点才会**最先碰撞**，一个点不可能越过另一个点去碰到另外一个点（~~俗称隔山打牛~~ ）。所以可以考虑先排序，再操作：

对于两个点$i$和$j$，如果碰撞的话，则若$x_i<x_j$，则在$mid$时刻，

$$
x'_i\ge x'_j \\
也即 \ \ x_i+v_i \times mid > x_j+v_j \times mid \\
令\ b_i=x_i+v_i\times mid \\
则需要求出满足 i<j且b_i>b_j的最长序列长度。
$$

这不就是求最长上升子序列吗？

故可以考虑**动态规划**来判断是否可以。

一次最长上升子序列为$O(n \log n)$，二分$\log n$，本题可以通过。

## $Code$

```cpp
#include <bits/stdc++.h>

#define N 100005

using namespace std;

int n, k;
struct node {
    int x, v;
    bool operator < (const node &t) const {
        return x < t.x;
    }
}a[N];

long double stk[N];

bool check(long double mid) {
    int m = 0; stk[0] = -1e20;
    for(int i = 1; i <= n; ++i) {
        long double now = a[i].x + mid * a[i].v; 
        if(stk[m] < now) 
            stk[++m] = now;
        else 
            stk[lower_bound(stk + 1, stk + 1 + m, now) - stk] = now;
    }
    return (n - m <= k);
}

int main() {

    cin >> n >> k;

    char tmp;

    for(int i = 1; i <= n; ++i) {
        cin >> a[i].x >> a[i].v >> tmp;
        if(tmp == 'L')
            a[i].v = -a[i].v;
    }

    sort(a + 1, a + 1 + n);

    long double l = 0, r = 2e9;
    for(int T = 0; T <= 50; ++T) {
        long double mid = (l + r) * 0.5;
        if(check(mid))
            l = mid; 
        else 
            r = mid;
    }

    if(check(l + 1)) 
        cout << "Infinity\n";
    else 
        printf("%.15Lf\n", l);
    return 0;
}
```

## $T2$ $首都$

> ## 题目描述
> 
> 北京有非常复杂的地铁网络，还有很多共享单车。
> 
> 北京有 $r$ 条双向道路，$s$ 条地铁线路。
> 
> 一共有 $n$ 个地点，标号 $1\sim n$。
> 
> 其中 THU 是 $1$ 号地点。
> 
> 小 H 可以骑共享单车通过道路。
> 
> 扫描和锁车总共需要 $x$ 的时间。
> 
> 第 $i$ 条道路连接第 $a_i$ 和第 $b_i$ 个地点，骑共享单车通过需要 $t_i$ 的时间。
> 
> 小 H 还可以坐地铁，但是他不能把共享单车骑进地铁里。
> 
> 每个地点都有一个地铁站（可能有的不通车），按照地点编号 $1\sim n$。
> 
> 第 $i$ 个地铁站需要 $e_i$ 的时间进站或出站。
> 
> 在第 $i$ 个地铁站换乘需要 $c_i$ 的时间。
> 
> 地铁有环线和非环线两种。
> 
> 每一条地铁线路都有一个起点站。
> 
> 对于每条环线地铁，今天早上 8:00 的时候有两列列车正好分别从起点站往两个方向驶出。
> 
> 对于每条非环线地铁，起点站是线路的一个端点，今天早上 8:00 的时候有一列列车正好从起点站驶出。列车到达线路的另一个端点之后会立刻返程，返程途中也会在经过的地铁站停车开门。
> 
> 每一条线路的发车都是均匀的。今天早上 8:00 时也已经有一些之前发车的列车在线路上。
> 
> 第 $i$ 条地铁线路的发车间隔是 $T_i$。环线地铁会向两个方向发车。并且没有早班车、末班车的安排，发车是持续不断的。
> 
> 地铁在站与站之间行驶需要时间。
> 
> 只有当 小 H 进站/换乘之后所在的地铁站有一列地铁到站停车开门时，小 H 才能上车。
> 
> 小 H 可以等待地铁到站。
> 
> 假设停车开门的时间计算在行驶时间中。
> 
> 假设 小 H 出站后能立刻找到一辆能用的共享单车。
> 
> 小 H 想知道，在今天早上 8:00 从 THU 出发到 个地点中的每个地点需要多少时间。
> 
> 注意最后一次锁车或者出站的时间要算在总时间中。
> 
> ## 输入格式
> 
> 第一行四个非负整数，$n,r,s,x$。
> 
> 第二行 $n$ 个正整数，表示 $e_i$。
> 
> 第三行 $n$ 个正整数，表示 $c_i$。
> 
> 接下来 $r$ 行，每行三个正整数，表示 $a_i,b_i,t_i$。
> 
> 接下来 $s$ 行，每行若干个正整数，格式如下：
> 
> - 第一个正整数 $k$，表示铁路的段数。
>   
> - 接下来 $2k+1$ 个正整数 $v_1,l_1,v_2,l_2,\cdots,v_k,l_k,v_{k+1}$，表示铁路按顺序经过的站点和行驶时间。
>   
>   其中 $v_1$ 是起点站，$v_{1\dots k}$ 两两不相同，$v_{2\dots k+1}$两两不相同。如果 $v_{k+1}=v_1$ 则说明该线路是环线，否则该线路是非环线。地铁在到达 $v_i$ 和到达 $v_{i+1}$ 之间需要经过 $l_i$ 的时间。
>   
> - 最后一个正整数 $T_i$，表示该线路的发车间隔。保证 $T_i|2\sum_{j=1}^kl_j$。如果线路是环线保证 $T_i|\sum_{j=1}^k l_j$。
>   
> 
> ## 输出格式
> 
> 一行，$n$ 个非负整数，其中第 $i$ 个表示 chj2001 从 THU 到 $i$ 号地点的最短时间。特别地，第一个数总是 $0$。
> 
> ## 样例 #1
> 
> ### 样例输入 #1
> 
> ```
> 4 0 1 1
> 6 6 6 6
> 2 2 2 2
> 3 4 3 1 7 2 15 3 10
> ```
> 
> ### 样例输出 #1
> 
> ```
> 0 26 41 16
> ```
> 
> ## 样例 #2
> 
> ### 样例输入 #2
> 
> ```
> 4 5 0 13
> 1 1 1 1
> 1 1 1 1
> 1 3 9
> 1 2 10
> 3 4 8
> 4 2 6
> 2 3 5
> ```
> 
> ### 样例输出 #2
> 
> ```
> 0 23 22 29
> ```
> 
> ## 样例 #3
> 
> ### 样例输入 #3
> 
> ```
> 13 2 3 8
> 14 16 16 16 16 16 16 16 16 16 16 16 16
> 22 32 32 32 32 32 32 32 32 20 32 32 32
> 3 8 4
> 11 13 4
> 6 2 3 3 3 4 3 5 3 6 3 1 3 2 1
> 3 7 6 8 6 9 6 10 1
> 2 12 12 10 12 11 1
> ```
> 
> ### 样例输出 #3
> 
> ```
> 0 33 36 39 36 33 86 48 86 92 124 124 136
> ```
> 
> ## 样例 #4
> 
> ### 样例输入 #4
> 
> ```
> 13 2 3 8
> 14 16 16 16 16 16 16 16 16 16 16 16 16
> 22 32 32 32 32 32 32 32 32 20 32 32 32
> 3 8 4
> 11 13 4
> 6 2 3 3 3 4 3 5 3 6 3 1 3 2 18
> 3 7 6 8 6 9 6 10 6
> 2 12 12 10 12 11 8
> ```
> 
> ### 样例输出 #4
> 
> ```
> 0 34 37 40 43 40 88 49 88 94 128 128 140
> ```
> 
> ## 提示
> 
> 在样例 1 中，由于 $r=0$ 所以只能坐地铁。在每个点进站或出站都会花费 $6$ 分钟（$e_i$）。
> 
> 只有一条地铁线路：$4 \to 1 \to 2 \to 3 \to 2 \to 1 \to 4 \to \cdots$，发车间隔为 $10$ 分钟（注意会返程）。
> 
> 我们在 $1$ 号点花费 $6$ 分钟进站，现在 8:06，然后需要等地铁。
> 地铁会在 ..., 7:40, 7:50, 8:00, 8:10, 8:20, ... 发车，那么下一辆地铁会在 8:13 到达。
> 
> 然后沿着铁路坐 $7$ 分钟，在 8:20 到达 $2$ 号地铁站，如果花 $6$ 分钟出站就是在 8:26 到达 $2$ 号点。$3$ 号点是类似的。
> 
> $4$ 号点：在 7:20 会发一次车，然后在 7:45 从 3 号地铁站往回开（因为会返程），在 8:07 到达 $1$ 号地铁站，乘坐这辆地铁，会在 8:10 到达 $4$ 号地铁站。
> 
> ---
> 
> 本题采用捆绑测试。
> 
> 保证 $1\leq n\leq 100000$，$0\leq r\leq 300000$，$0\leq s\leq 100000$，$1\leq x\leq 10^9$。
> 
> 保证 $1\leq e_i,c_i,l_i\leq 10^9$。
> 
> 保证 $c_i\leq 2e_i$。
> 
> 保证 $1\leq a_i,b_i\leq n$，$1\leq t_i\leq 10^9$。
> 
> 保证 $1\leq k\leq n$，$\sum k\leq 2\times 10^5$，$1\leq v_i\leq n$。
> 
> 保证 $T_i|2\sum_{j=1}^kl_j$。如果线路是环线保证 $T_i|\sum_{j=1}^kl_j$。
> 
> 保证如果 $v_1=v_{k+1}$ 那么 $k\ge 3$。
> 
> 保证 小 H 能够到达每个地点。
> 
> ### 子任务 1（7 pts）
> 
> $s=0$，即没有地铁线路。
> 
> ### 子任务 2（16 pts）
> 
> $s\leq 5,x=0,T=1$。
> 
> ### 子任务 3（19 pts）
> 
> $s\leq 5,T=1$。
> 
> ### 子任务 4（28 pts）
> 
> $T_i=1$，即每条地铁线路的发车间隔都是 $1$，这意味着幸运的 小 H 永远不需要等车。
> 
> ### 子任务 5（15 pts）
> 
> $n\leq 1000$。
> 
> ### 子任务 6（15 pts）
> 
> 无特殊限制。

1. 多建点：“自行车站”，“地铁站”。
  
2. 注意到，可以把自行车的“开锁”和“锁车”都看成开锁，即只有开锁需要时间，故可以再自行车站和地点之间连一条价值为开锁时间的边，然后再在自行车站之间建边。地铁站同理。
  

## $T3$ $惩罚$

> ## 题目描述
> 
> 我发现你在打摆，于是把你关进了一个树形迷宫的根节点里面。
> 
> 唯一的出路在根节点，但是你要出去，就必须解除所有叶子节点的封印。定义叶子节点为度数为 $1$ 的非根节点。
> 
> 每个叶子节点上都有一个数，开始时是 $0$。我给每个叶子节点都设了一个密码，然而你目前并不能看到它们。
> 
> 你可以改变叶子节点上的数字，方法是这样的：在某个节点的机器上输入一个整数 ，使这个节点的子树中所有叶子节点的数加上 $v$。形式化地，如果节点 $x$ 在根节点与节点 $y$ 的唯一简单路径上，那么说明节点 $x$ 在节点 $y$ 的子树中。
> 
> 要操作一个机器，你需要得到机器的口令。获取口令只有一种方法，就是做一定数量的题，然后找我换取口令。知道口令之后你就可以使用机器任意多次。不同的节点的机器的口令不同，获得口令所需做的题数也可能不同。
> 
> 把一个叶子节点的数调整为和这个叶子节点上的密码一致，就可以解除这个叶子的封印，但只有在同一时刻所有叶子节点的数和各自的密码均相等时，位于根节点的出口才会打开。
> 
> 你当然也可以向我询问每个叶子节点上的密码。但是我一旦把任何叶子上的密码告诉你，你就再也不能向我要到任何的口令了，即使做再多的题也不行。我当然可以把密码设得刁钻一些来恶心你。
> 
> 你想知道三件事情：
> 
> 1. 你至少要做多少道题才能保证逃出去。
> 2. 在上述情况下你可能可以得到哪些机器上的口令。也就是说，对于哪些机器，存在一种做题量最少的方案，使得你需要获取这个机器上的口令。
> 3. 在 1. 的情况下有多少获得口令的方案可以保证能逃出去，两种方案不同当且仅当存在一台机器，在一种方案中你获取了它的口令而另一种方案中没有。答案对 $998244353$ 取模。
> 
> ## 输入格式
> 
> 第一行一个正整数 $n$，表示树形迷宫的节点总数。其中根节点为 $1$ 号节点。
> 
> 接下来一行 $n$ 个正整数，其中第 $i$ 个数 $c_i$ 表示为了获取编号为 $i$ 的节点的机器的口令你需要做的题数。
> 
> 接下来 $n - 1$ 行，每行两个正整数，表示树形迷宫一条边的两个端点。
> 
> 最后一个正整数 $k$，表示你需要回答前 $k$ 个问题。
> 
> ## 输出格式
> 
> 第一行输出一个整数，表示第一个问题的答案。
> 
> 如果 $k\ge 2$，第二行按从小到大的顺序输出若干个整数，表示第二个问题的答案中所有机器所在节点的编号。
> 
> 如果 $k\ge 3$，第三行输出第三个问题的答案模 $998244353$ 的值。
> 
> ## 样例 #1
> 
> ### 样例输入 #1
> 
> ```
> 5
> 500 100 300 200 100
> 1 2
> 2 3
> 2 4
> 1 5
> 3
> ```
> 
> ### 样例输出 #1
> 
> ```
> 400
> 2 4 5
> 1
> ```
> 
> ## 样例 #2
> 
> ### 样例输入 #2
> 
> ```
> 3
> 100 100 100
> 1 2
> 1 3
> 3
> ```
> 
> ### 样例输出 #2
> 
> ```
> 200
> 1 2 3
> 3
> ```
> 
> ## 提示
> 
> 本题采用捆绑测试。
> 
> 保证 $2\leq n \leq 10^6$，$1\leq c_i\leq 10^9$，$1\leq k\leq 3$。
> 
> 保证输入的是一棵树。
> 
> ### 子任务 1（14 pts）
> 
> $k=1$。
> 
> ### 子任务 2（21 pts）
> 
> $k\leq 2$。
> 
> ### 子任务 3（14 pts）
> 
> $n\leq 10$。
> 
> ### 子任务 4（21 pts）
> 
> $n\leq 200$。
> 
> ### 子任务 5（15 pts）
> 
> $n\leq 3000$。
> 
> ### 子任务 6（15 pts）
> 
> 无特殊限制。

1. 树形dp，维护这个店选不选（不能满分）
  
2. 差分，dfs序。
  
3. 最小生成树。
  

## $T4$ $NOIP2024 充满了希望$

> ## 题目背景
> 
> 小 G 很喜欢数据结构，尤其是 Ynoi。
> 
> 这天小 G 做了一道 Ynoi 题：[[Ynoi2012] NOIP2015 充满了希望](https://www.luogu.com.cn/problem/P5524)。他觉得这题实在是太有趣了，尤其是每次对序列进行一系列 2 操作的区间推平。所以他对这题进行了加强。
> 
> ## 题目描述
> 
> 给一个长为 $n$ 的序列，有 $m$ 个操作，操作编号从 $1$ 到 $m$，每个操作为：
> 
> 给定 $l,r$，将序列区间 $[l,r]$ 内所有元素修改为 $x$，$x$ 为区间 $[l,r]$ 内当前的最大值。
> 
> 现在有 $q$ 次事件，每次事件会对序列进行修改或查询：
> 
> 1. 修改：给出 $x,y$，将序列位置为 $x,y$ 的两个元素交换。
> 2. 修改：给出 $x,v$，将序列第 $x$ 个位置上的值改为 $v$。
> 3. 修改：给出 $l,r,v$，将序列区间 $[l,r]$ 内所有元素对 $v$ 取模。
> 4. 查询：给出 $l,r,x$，**假如**对序列依次进行 $l$ 到 $r$ 的所有操作，位置 $x$ 上的值会变成多少。
> 
> ## 输入格式
> 
> 第一行两个整数 $n$，$m$，表示序列长度和操作的个数。
> 
> 第二行 $n$ 个整数，第 $i$ 个整数 $v_i$ 表示序列第 $i$ 个位置上的值。
> 
> 接下来 $m$ 行，每行两个整数 $l_i,r_i$，表示第 $i$ 次操作的区间。
> 
> 接下来一行一个整数 $q$，表示事件数量。
> 
> 接下来 $q$ 行，每行首先一个整数 $op$，表示事件的种类。如果 $op = 1$，那么接下来两个整数 $x,y$；如果 $op = 2$，那么接下来两个整数 $x,v$；如果 $op = 3$，那么接下来三个整数 $l,r,v$；如果 $op=4$，那么接下来三个整数 $l,r,x$。具体含义见题目描述。
> 
> ## 输出格式
> 
> 对于每个第四类事件，输出一行一个整数表示答案。
> 
> ## 样例 #1
> 
> ### 样例输入 #1
> 
> ```
> 78 71
> 8 25 20 37 10 65 34 27 74 70 78 48 12 11 31 38 75 15 24 63 66 64 29 3 46 58 4 67 72 54 18 36 14 28 21 60 44 50 30 68 57 23 43 2 35 5 42 62 73 13 22 77 55 32 39 53 16 47 49 76 17 51 41 45 6 40 56 1 52 9 71 61 26 7 33 19 69 59
> 2 30
> 20 45
> 39 61
> 25 78
> 30 59
> 11 65
> 18 63
> 23 60
> 49 52
> 56 66
> 17 31
> 21 46
> 44 58
> 68 77
> 34 45
> 44 49
> 51 66
> 27 70
> 40 71
> 3 9
> 55 59
> 38 63
> 10 36
> 24 25
> 17 67
> 11 55
> 11 52
> 13 48
> 24 42
> 3 69
> 44 77
> 7 66
> 59 60
> 28 45
> 50 63
> 6 74
> 42 70
> 41 42
> 62 68
> 3 27
> 38 78
> 8 42
> 54 68
> 28 69
> 24 60
> 28 78
> 8 48
> 5 44
> 47 47
> 4 59
> 4 21
> 23 32
> 13 31
> 36 53
> 9 66
> 39 78
> 6 71
> 10 29
> 58 75
> 6 7
> 28 34
> 38 67
> 32 66
> 26 54
> 11 19
> 13 18
> 33 69
> 10 12
> 1 43
> 6 9
> 36 78
> 68
> 1 36 27
> 2 68 92
> 2 1 56
> 1 76 28
> 4 34 56 40
> 2 58 42
> 2 72 116
> 2 78 139
> 4 5 14 16
> 1 12 75
> 1 63 3
> 1 9 15
> 4 17 36 50
> 2 7 177
> 4 34 68 48
> 1 11 1
> 2 62 262
> 2 19 32
> 2 39 391
> 2 32 544
> 2 12 329
> 2 64 770
> 1 8 58
> 1 68 70
> 1 31 9
> 1 3 32
> 1 27 74
> 2 73 1192
> 2 67 1993
> 1 15 11
> 4 37 63 60
> 2 5 530
> 1 70 71
> 2 38 1703
> 1 16 8
> 1 47 26
> 2 39 3822
> 1 42 60
> 1 59 57
> 4 39 71 16
> 2 26 2423
> 2 31 6199
> 2 33 12396
> 2 58 15
> 2 58 10159
> 2 37 7752
> 2 38 19090
> 1 25 75
> 2 71 23576
> 2 53 34786
> 1 42 64
> 2 8 2022
> 4 25 30 4
> 1 13 71
> 1 53 40
> 2 64 38979
> 1 69 63
> 1 24 74
> 1 36 50
> 2 50 925
> 2 7 15806
> 2 58 13945
> 2 11 19589
> 2 50 41458
> 4 52 68 58
> 1 52 11
> 1 43 74
> 4 12 12 35
> ```
> 
> ### 样例输出 #1
> 
> ```
> 92
> 78
> 116
> 177
> 1993
> 3822
> 34786
> 41458
> 34786
> ```
> 
> ## 提示
> 
> 对于所有测试点：$n, m, q \leq 5 \times 10 ^ 5$，$1\leq l_i \leq r_i \leq n$，$x \leq n$，$l \leq r$，$op\in \{1, 2,3,4\}$，$v \leq 10 ^ 9$。
> 
> 每个测试点的具体限制见下表：
> 
> | 测试点编号 | $n\leq$ | $m\leq$ | $q\leq$ | 特殊限制 |
> | --- | --- | --- | --- | --- |
> | $1,2$ | $100$ | $100$ | $100$ |     |
> | $3,4,5$ | $2000$ | $2000$ | $2000$ |     |
> | $6,7,8,9$ | $300$ | $300$ | $5 \times 10 ^ 5$ | $op = 4$ |
> | $10,11,12,13$ | $5 \times 10 ^ 5$ | $5 \times 10 ^ 5$ | $5 \times 10 ^ 5$ | $r_i < l_{i + 1}$ |
> | $14,15,16,17,18$ | $10 ^ 4$ | $10 ^ 4$ | $10 ^ 4$ |     |
> | $19,20$ | $5 \times 10 ^ 4$ | $5 \times 10 ^ 4$ | $5 \times 10 ^ 4$ |     |
> | $21,22,23,24,25$ | $5 \times 10 ^ 5$ | $5 \times 10 ^ 5$ | $5 \times 10 ^ 5$ |     |
> 
> 此外，对于所有奇数编号的测试点，不存在三操作。

1. 单点修改。
  
2. 交换位置上的数。
  
3. 区间取模。
  
  - 成功取模：$w \% v<w$，至多$log_2w$次。
    
  - 区间找最大值来反复取模（线段树），线段树维护区间的最大值：
    
    - 如果区间$max$比$v$大，递归到两个儿子节点，区间取模。
      
    - 如果小，就停止。
      

```cpp
void mod(int p, int l, int r, int ql, int qr, int v) {
    if(tree[p] < v) {
        return;
    }
    if(l == r) {
        tree[p] %= v;
        return;
    }
    int mid = l + r >> 1;
    if(ql <= mid)
        mod(i << 1, l, mid, ql, qr, v);
    if(qr > mod)
        mod(i << 1 | 1, mid + 1, r, ql, qr, v);
    tree[p] = max(tree[i << 1], tree[i << 1 | 1]);
}
```

4. 其他的听不懂了思密达。
